### PART2.자바스크립트 기초 다지기



# 016. 숫자형 이해하기

- 다른 프로그래밍 언어와 달리 자바스크립트는 숫자의 형태를 구체적으로 나눠 정의하지 않음
- 정수, 부동 소수점, 작은 수, 큰 수 등 여러 유형의 숫자를 '숫자형(Number)' 하나로 정의
- 이외에 자바스크립트에는 Infinity, NaN 값이 있음, 숫자형으로 분류되지만, 일반적인 숫자와는 조금 다른 역할을 수행
- Infinity : 다른 어떤 수 보다 큰 수 (무한대)
- NaN : Not a Number ㄹ는 뜻으로, 산술 연산의 결과가 유효하지 않은 값 또는 숫자가 너무 커서표현할 수 없는 값일 때 표현됨


# 019. null 과 undefined 이해하기

- null : '비어있는, 존재하지 않는 값'을 의미  / 값의 부재를 의미, 원시 자료형 null로 분류
         typeof로 자료형을 확인할 때 object(객체)를 반환하는데 이는 자바스크립트 기존 이슈로 인한 결과이므로 null 이 객체형이라 오해하지 않도록 주의!

- undefined : 변수가 정의되었지만, '아무 값도 할당받지 않은 상태'를 의미
	     예를 들어 함수에서 명시적으로 값을 반환하지 않았을 때 또는 변수에 어떠한 값도 대입하지 않고 정의했을 때 undefined가 반환됨 / undefined 원시 자료형으로 분류됨


# 021. 산술 연산자 (덧셈, 뺄셈, 곱셈, 나눗셈)

- 자바스크립트의 산술 연산자는 숫자형 값 연산에만 국한되지 않음
- 덧셈(+) 연산자인 경우 문자형에 사용 가능 / 두 개 이상의 문자열을 이어 붙일 수 있음 / 나머지 연산자는 문자열 사용X
- 산술 연산자에 =연산자를 함께 사용하는 '산술 등호 연산'도 가능 (+=, -=, *=, /=)
- 이외에도 나머지 연산자(%), 거듭제곱 연산자 (**), 단항음수/양수 (+ / -), 증감 연산자(++ / --) 가 있음


# 022. 비교 연산자

- 비교 연산자는 두 개의 값을 비교하여 true, false 결과값을 반환

* 종류
- 일치 연산자 : 값이 동등한지 비교 (값의 일치 여부)
   - 동등 연산자 (==) : 비교 대상값의 자료형이 서로 다르면 강제로 형을 바꾼 뒤 비교
		     값의 자료형과 상관없이 내용이 같은 경우 참(true)을 반환 / 만약 두 값이 객체형이라면 메모리 주소를 바라보는지 확인
   - 부등 연산자 (!=) : 값이 다른 경우 참(true)을 반환 / 자료형이 다른 경우 동등 연산자와 동일하게 형을 변환하고 비교하게 됨
   - 일치 연산자 (===) : 앞에 연산자들보다 엄격한 기준을 갖고 있음 / 값의 내용과 자료형까지 일치하는지 비교 / 자료형을 임의로 변환하지 않음
   - 불일치 연산자 (!==) : 앞에 연산자들보다 엄격한 기준을 갖고 있음 / 같은 자료형에서 값의 내용이 다르거나 다른 자료혀인 경우 참(true)을 반환

- 관계 연산자 : 값의 관계를 비교 (두 개의 값 간의 크기 비교를 통해 관계를 확인) / >, <, >=, <= 가 있음


# 023. 논리 연산자

- 어떠한 명제에 대한 논리적인 판단을 내리는 연산자 / 참 또는 거짓의 값을 받아 논리적 연산의 결과로 true, false를 반환
- 종류 : AND연산자 '&&', OR연산자 '||', NOT연산자 '!' 가 있고, 결과값은 항상 Boolean 자료형으로 반환
- !! 연산자 : not 연산자에 한 번 더 not 연산자를 처리하는 방법
- Boolean 자료형이 아니더라도 값을 논리 연산자로 처리하면 참인지 거짓인지 구분할 수 있음
- 값의 정보가 유효한 경우 참(true)인 값 : 3, 10, '문자', true, [1, 2, 3], {tom: 'boy'}, function() {}
- 값의 정보가 비어 있는 경우 거짓(false)인 값 : false, 0, -0, "", NaN, null, undefined


# 024. 삼항 연산자

- 삼항 연산자는 if와 switch처럼 조건문을 처리하는 연산자 / 조건문 ? 표현문1 : 표현문2 => 조건문 결과가 true 이면 표현문1 실행, false이면 표현문2


# 026. 자료형 변환 이해하기

- 자바스크립트에서는 자료형 간 변환을 지원함 (숫자형 => 문자형 or 문자형 => 숫자형) => '자료형 변환 (type coercion)', '형변환'
* 변환 방법
1) 개발자가 직접 명시적으로 자료형 변환
2) 자바스크립트 엔진에 의해 자동으로 자료형이 변환되는 방법 : 자바스크립트가 동적 자료형 언어이기 때문에 적용되는 특징


# 027. 배열 이해하기

- 배열 자료형의 형태는 '대괄호 []' 와 괄호 사이의 '요소' 로 구성됨 / 요소가 없는 대괄호 [] 는 빈 배열을 의미
- 배열에 요소들을 나열하는 경우 '콤마(,)'를 통해 구분 => [요소1, 요소2, 요소3]
- 자바스크립트는 동적 자료형 성격을 갖고 있기 때문에, 배열의 길이와 자료형은 고정되지 않음 / 배열의 길이란 '배열 내부의 요소 개수를 계산한 값'


# 028. 객체 이해하기 1

- 여러 개의 값을 한번에 접근할 수 있도록 '객체(Object)' 를 제공하고 있음 (값들을 그룹으로 묶은 데이터 모음)
- 객체는 '중괄호 {} ' 사용, 중괄호 안에 여러 값들을 넣을 수 있는데, 키(Key)와 값(Value)을 한 쌍으로 정의하며 '속성(Properties)' 라고 부름 => {Key : Value}
- 하나의 키(Key)에는 하나의 값이 맵핑, 객체 안에 중복된 키 이름은 허용X
- JSON은 자바스크립트의 객체와 매우 유사한 구조를 지닌 데이터 교환 형식(format)
- JSON 형태는 객체와 비슷하게 키 : 값 쌍의 모음들로 이루어져 있음 (속성 키 이름은 " " 로 표시된 문자열이여야 함 / 값은 오직 문자열, 숫자, 배열, true, false, null 또는 다른 JSON 객체만 가능) => {"Key" : Value}


# 029. 객체 이해하기 2 (속성 접근/추가/수정/삭제)

- 객체의 속성에 접근하는 방법은 객체의 우측에 '콤마 (.)' 를 두고 그 다음에 객체 속성으로 정의된 키 이름을 작성하면 됨 (대괄호 ([]) 안에 키 값을 문자열로 작성하는 방법도 있지만 콤마를 더 선호)
- 객체에 속성을 추가/수정/삭제 방법 또한 속성에 접근하기 때문에 콤마 또는 대괄호를 사용하는 방식과 유사


# 030. ES6의 향상된 객체 문법 알아보기 - 단축 속성명

- 객체 속성을 리터럴로 정의하기 위해서는 '키 : 값' 으로 작성해야만 했음
- '단축 속성명' 을 활용해 객체의 속성을 좀 더 간단하게 정의할 수 있음
- 단축 속성명은 변수가 미리 준비되어 있는 경우 활용 가능하며, '변수명'으로 속성의 키와 값을 한번에 정의할 수 있음


# 031. ES6의 향상된 객체 문법 알아보기 - 속성 계산명

- '속성 계산명'은 속성 이름을 정의하는 다른 방법 / 대괄호 [] 안에 식을 넣거나 변수를 대입하여 동적으로 객체 속성들을 생성할 수 있음


# 032. ES6의 향상된 객체 문법 알아보기 - 비구조화 할당

- 배열이나 객체의 값을 새로운 변수에 쉽게 할당하는 방법
- ES6 이전에는 변수 하나에 값 하나를 일일이 할당해야 했으나 ES6부터는 비구조화 할당을 통해 손쉽게 값을 할당할 수 있게 됨


# 034. 함수 이해하기

* 함수 형태
function 함수 이름 (매개변수 목록) {
	함수 실행부
}

- 키워드 function : 함수 자료형은 키워드 function을 앞에 붙여 함수로 정의 (ES6 부터는 function 없이 함수로 정의 가능)
- 함수 이름 : function 과 소괄호 () 사이에 이름을 정의, 이를 통해 함수 식별 가능
	    함수 내에서 재귀로 자기 자신을 참조할 수 있음, 이름을 정의하지 않은 함수는 '익명 함수' 라고 부름
- 매개변수 목록 : 함수 선언 시 매개변수 목록을 정의하면 함수를 호출할 때 인자값을 전달할 수 있음
- 함수 실행부 : 함수가 호출되면 실행되는 몸통부로 중괄호 {} 안에 코드 작성


# 035. 예외 처리하기

- 자바스크립트 코드를 실행하다 에러가 발생하면 그 즉시 중단됨, 이를 대비해서 예외 처리는 반드시 필요
- 자바스크립트에서 사용할 수 있는 예외 처리 방법에는 throw문과 try ~ catch ~ finally 문이 있음

* 예외 처리 시 에러 종류
1) 예상치 못한 에러
2) 개발자가 의도한 에러 : 코드에서 잘못될 가능성을 예상하고 발생시키는 에러를 의미 => throw문 사용, throw문은 고의로 에러를 발생시켜 예외 상황을 알리는 역할, throw문이 실행되면 실행되고 있던 블록을 빠져나감

* 예외 처리 방법
1) throw 문 : 고의로 에러를 발생시켜 예외 상황을 알리는 역할, throw문이 실행되면 실행되고 있던 블록을 빠져나감
2) try ~ catch ~ finally 문 : try 블록 안에서 발생된 에러를 잡아내고 catch 블록으로 제어권을 넘김, try 블록에서 발생된 에러 정보는 catch 문의 변수로 전달되기 대문에, 개발자는 프로그램 종료 없이 어떤 에러가 발생했는지 확인할 수 있음
		          finally 블록은 에러 발생 여부와 상관없이 실행되는 블록 / ex) 파일 읽기/쓰기를 할 때 에러가 발생되더라도 항상 파일 close 구문을 실행할 수 있음


# 036. arguments 객체 이해하기

- 자바스크립트 함수는 매개변수와 같이 전달 인자(argument) 도 사용됨
- 매개변수가 함수 선언 시 작성되는 변수라면, 전달 인자는 함수가 호출될 때 전달되는 값
- 전달 인자의 개수와 매개변수의 개수가 달라도 에러를 발생하지 않음, 그래서 매개변수와 무관하게 함수 호출 시 더 많은 인자를 전달할 수 있음, 매개변수 외에 함수에서만 사용가능한 특별한 객체


# 037. 함수 기본 매개변수 처리하기

- ES6에 새롭게 추가된 '기본 매개변수'는 매개변수를 정의할 때 기본으로 할당될 인자값과 함께 작성하는 매개변수, 값을 할당하는 연산자인 '='를 이용해 정의


# 038. 함수 나머지 매개변수 이해하기

- ES6에서 새로 추가된 '나머지 매개변수'는 매개변수를 정의할 때 정해지지 않은 매개변수들을 정의할 수 있게 함
- arguments 객체와 유사하나 arguments 객체는 함수에 전달되는 모든 전달 인자를 포함하는 반면에, 나머지 매개변수는 정해지지 않은 나머지를 의미
- 나머지 매개변수는 arguments 객체와 다르게 매개변수를 작성하는 곳에서 작성하고, 다른 매개변수와의 차이점을 두기 위해 '... 연산자' 와 함께 작성
- arguments 객체와 나머지 매개변수와의 가장 큰 차이점은 arguments 객체는 배열이 아니지만 나머지 매개변수는 배열임

* 형태
function(parameter, ...restParameter) {
	// arguments 객체는 나머지 매개변수와 다르게 함수 몸통에서만 사용
}


# 039. 스코프 이해하기

- 스코프는 '유효 범위'로써 변수와 매개변수가 어디까지 유효한지를 나타냄 / 코드에서 a라고 작성했을 때 a라는 식별자가 어디를 참조할지, 실제 값이 무엇인지를 찾을 때 스코프를 활용
- 자바스크립트는 기본적으로 '전역'과 '함수' 단위로 스코프를 생성
- 함수 안에서 선언된 변수는 함수 블록 안에서만 접근이 가능, 전역에 선언한 변수들은 코드어디에서든 접근 가능
- 스코프는 일반적으로 렉시컬(Lexical) 스코프와 다이나믹(Dynamic) 스코프로 분류
- 렉시컬 스코프는 코드를 작성하는 시점에 스코프가 결정되어진다고 해서 '정적 스코프'라고 부름 / 자바스크립트는 대표적인 렉시컬 스코프


# 040. 함수 호이스팅 이해하기

- 자바스크립트에서는 함수를 선언하기 전에 호출이 가능함, 이러한 현상을 '호이스팅' 이라고 함


# 041. let으로 변수 선언하기

- ES6에서 'let' 키워드가 나오면서 변수 선언 시 변수의 유효 범위를 블록 범위로 지정할 수 있게 됨


# 042. const로 상수 선언하기

- ES6에서 추가된 'const' 키워드는 let 키워드와 마찬가지로 블록 단위로 스코프를 정의할 수 있음
- let 과의 차이점은 선언 시 값을 할당해야 하고 이후 재할당을 할 수 없음
- const 키워드로 정의된 상수에 객체를 할당하면 불변 객체(Immutable Object)가 되지는 않음, 불변 객체는 정의된 후 그 상태를 바꿀 수 없는 객체를 의미


# 043. 스코프 체인 이해하기

- 스코프 체인은 문자 그대로 스코프가 연결되어 있음을 나타냄, '실행 컨텍스트(Execution Context)' 와 '렉시컬 환경(Lexical Environment)' 에 대해 알아야 함
- '실행 컨텍스트'는 코드가 실행되기 위해 필요한 정보를 가지고 있음, 실행 컨텍스트는 실행 가능한 코드가 실행될 때 생성됨
- 대표적인 실행 가능한 코드로는 전역 코드와 함수 코드가 있음, 그 외에 eval과 모듈 코드도 있음

- 처음에는 전역 코드가 먼저 실행됨, 이때 전역 컨텍스트를 만들고 전역 코드를 순차적으로 평가
- 그러다 함수가 호출문을 만나면 새로운 실행 컨텍스트가 만들어지면서 해당 함수 실행부의 코드를 순차적으로 평가함
- 이때 스택(Stack) 을 이용해 실행 컨텍스트를 관리하게 되는데, 새로운 실행 컨텍스트가 생성되면 스택에 쌓고 실행 중인 코드가 종료되면 해당 실행 컨텍스트를 스택에서 제거함

- 실행 컨텍스트는 렉시컬 환경을 가지고 있는데, 렉시컬 환경은 '환경 레코드(EnvironmentRecord)' 와 '외부 렉시컬 환경(OuterLexical Environment)' 로 구성됨


# 044. 클로저 이해하기

- '클로저' 란 함수가 정의될 때의 렉시컬 환경을 기억하는 함수를 말함


# 045. 객체 속성 기술자 이해하기

- 자바스크립트의 모든 객체 속성은 자기 자신에 대한 정보를 담고 있는 '속성 기술자(Property Descriptor)' 를 가지고 있음, 객체로 표현됨
- Object.defineProperty를 통해 객체의 속성을 정의할 때 '속성 기술자'를 이용하여 정의할 수 있음

* 속성 기술자의 속성
- value : 값
- enumerable : for...in 루프나 Object, Keys 메소드같이 속성을 나열할 때 나열 가능 여부를 정의, false일 경우 나열되지 않음
- writable : 값을 변경할 수 있는 여부를 정의, false일 경우 값이 변하지 않음
- configurable : 속성 기술자를 변경할 수 있는 여부를 정의, false일 경우 속성 기술자를 다시 변경할 수 없음


# 047. 화살표 함수 이해하기

- ES6에서는 기존 함수를 간결하게 표현할 수 있고 기능이 개선된 '화살표 함수'가 추가됨
- 화살표 함수는 function 키워드를 사용하지 않고 화살표 모양의 '=> 연산자' 를 이용하여 정의

* 화살표 함수 규칙
- 매개변수가 하나일 경우에는 인자를 정의할 때 괄호 생략 가능
- 매개변수가 없거나 둘 이상일 경우 괄호를 작성해야 함
- 화살표 함수 코드 블록을 지정하지 않고 한 문장으로 작성 시 return 문을 사용하지 않아도 화살표 오른쪽 표현식의 계산 결과가 반환됨
- 화살표 함수 코드 블록을 지정했을 경우 반환하고자 하는 값에 return 문을 작성해야 함, return 문이 없을 시 undefined가 반환됨

















